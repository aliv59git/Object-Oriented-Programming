Бележки по първа лекция: 

Когато въвеждаме константа public const double PI=стойност, трябва да въведем числена стойност. 
Когато въвеждаме рийд онли константа не е нужно да въвеждаме стойност, а само я декларираме с име: public readonly double Size;
В конструктора въвеждаме нейната стойност. Няма проперти. След като веднъж се въведе, стойността не може да се променя. Като const
В Main() се извикват през името на класа с главна буква! Както и всичко статично! При създаване на нова константа, тя се създава като рийд-онли константа през името на класа само! т.е. константа от тип името на класа!
	Важно! Стойността на рийд-онли константата след създадена инстанция (т.е. нова константа през името на класа) се достъпва през инстанцията с точкова нотация и името на тази константа в класа:  c.Size; dou.Size; Така се извиква и отпечатва! 

Внимание! В Сетера се проверява value. Т.е. всички проверки за валидация трябва да бъдат по отношение на "value"!!! Накрая се сетва стойността на съответното проперти с израза this.name = value; (or age, или нещо друго, за каквото е пропертито). 

В конструктора има само public.. и името на класа и () със или без параметри. В пропертито има public.. и int/string/.. С гл.буква
В кода когато пишем this. след това пропертито е с Главна Буква!!! Защото е името на съответното поле, а не неговата стойност. За да могат да се запишат с главна буква в конструктора, т.е. да се минава през пропертито (и съответно да може да се извърши съответната валидация на входните данни) трябва преди това да са направени пропертитата (при тях имената са с гл. букви). Следователно: правим си полетата private (ако има такива); Правим си пропертитата (get; set;), евентуални валидации; И тогава преди тях си правим конструкторите; След тях ако има си правим методите. Валидациите могат да бъдат изнесени накрая в отд. методи. 
След this. с главна буква е в конструкторите; иначе може и с малка буква. 

При енумерациите. Прави се инстанция без new и се присвоява през името на енумерацията съответната конкретна стойност. 
DayOfWeek day = DayOfWeek.Wednesday;

Валидация на данните в пропертитата. След това в Main() също при правенето на инстанции на класа - през try - catch + Exception ex може



Бележки по втора лекция

В конструктора за някакво свойство, което е зададено автоматично, задава стойност числена, с главна буква е и го няма в параметрите на конструктора. Ако го има в параметрите, тогава не задава числена стойност, а от полето. 

Когато използва друг клас/енумерация(цвят на котките) в базовия (котка) прави проперти от тип енумерацията с главна буква и get; set; Това свойство може да си вкюлчи в конструктора с малка буква. 
	Добавя си в полетата private List<Cat> cats; и тази колекция инициализира в конструктора. Преди това си прави метод за добавяне на котки към List<Cat> cats:
public void AddCat(Cat cat, string name)
{
	if(this.cats.Contains(cat))
	{
		throw new ArgumentException("...");
	}
	cat.Name = name;
	cat.Owner= this;
	this.cats.Add(cat);	
}				Но сега за да работи трябва да добави листа в контруктора. Задължително там трябва да кажем: this.cats = new List<Cat>(); 
	Ще го направя като проект по лекцията на Ивайло във VS. 

Когато в полетата отгоре се декларира масив, или някаква лист колекция, тогава в конструктора задължително с това име (декларираното горе) се дава образуване на инстанция с new ... . В статичния контруктор при статични масиви може да има и цикъл с инициализацията на този масив. 

Интересен начин на използване на подполетата е дадено във демото DefiningClass-2, 2.Structures: /така прави цвета/в 
public override string ToString() -> "surface(#{4:X2}{5:X2}{6:X2}), border(#{7:X2}{8:X2}{9:X2})", this.SufaceColor.RedValue, this.SurfaceColor.GreeVlue, this.SurfaceColor.BlueValue и същото за 7, 8 и 9 но BorderColor.
	Важно! Навсякъде където има пропертита, а и в методите ползва this.

	Важно!!! Всички неща, които искаме да са използват, има ги в полетата горе, за да работят трябва да се инстанцират в конструктора. Иначе няма да работят!!! Горе има: private List<Cat> cats; В конструктора трябва да добави: 
this.cats = new List<Cat>(); т.е. да направи инстанция на листа (или масива). Тогава вече той ще работи. Може би затова не мога да използвам battery и display при GSM-a. от първото домашно. 
В конструктора пишем this.Name = name; С главна буква, за да мине през пропертито и да изпълни валидацията. Там където нямаме полета - може автоматично проперти за това свойство. Иначе с поле и с валидация. Пишеш само автоматични пропертита, ако ти трябва валидация - с полета и неавтоматични пропертита. 
	До тук беше преговор от първата лекция - това за котките. 

Статични неща - могат да се сетват на: Fields, Properties, Methods, Events, Constructors. Статичното е общо за целия клас и се достъпва през името на класа (с гл. буква); Нестатичното е свързано с инстанцията и се достъпва през нея (след като се направи спооред конструктора с new ... . 
	Ако един клас е статичен, нищо инстанционно не може да съществува в него и не можем да създаваме такова. В общия случай искаме нещата да не са статични. 

Структури - Стойностни типове данни и се държат като примитивни типове данни. Структурата се копира, докато класа се подава по референция. Структури се използват когато имаме да пазим няколко данни. Координати на точка, и др. Когато обаче имаме някаква логика - да е клас. Иначе няма голяма разлика между тях class and struct, но в памета се държат по различен начин. Всички примитивни типове данни са структури. Само стринга е клас, но се държи като примитивни данни.

Generics class - GenericList<T>, T = int, string, Cat, ... може и два параметъра: Generic<T, K>. При създаване на инстанцията, трябва да укажем типа/типовете данни. Има обаче известни ограничения. Това Т се държи като обект. Т.е. компилаторът не знае какъв е типа данни, т.е. не можем да извършваме някои операции. (Събиране, изваждане умнажение... сравняване... ) Имаме някакви възможности да ги сравняваме, но по-нататък. Можем да кажем измежду какви типове данни да бъде Generic - a.

Освен Generic класове можем да имаме Generic методи.  Можем да направим метода Generic за да работи с повече от 1 тип данни, за да не правим  едно и също. Когато имаме where T: struct  или where T: class веднъж работи само със структури, а в другия случай - с класове, но не и със структури като int, bool, long... Когато след where има new() означава да има празен конструктор. Могат след where да се изреждат, но редът е: class, IComparable<T> 

Неймспейси . В тях се съдържат класове (дефиници на типове). След като се смени неймспейса на даден клас, той вече не разпознава другите класове, които не са в този неймспейс. Ако са в различни неймспейси, можем да укажем отгоре с using кой неймспейс да разпознава допълнително (освен собствения неймспейс) този клас. 
	Всеки един неймспейс не е задължително да се дефинира в един и същи файл. Всеки от класовете на неймспейса вижда останалите, които са в същия неймспейс. По този начин можем да имаме с еднакви имена класове, но в различни неймспейси. Горе преди мейн метода указваме using FirstCat = CatSystem.Cat; и също така using SecondCat = AnimalSystem.Cat;

След using .... (горе) точките в името разграничават поднеймспейси. По такъв начин могат да се разграничават и групират нещата. 

Ако един клас стане много дълъг - разделяме на множество класове; Ако един метод стане много дълъг - разделяме на много методи. 
Отговорностите се разделят на по-малки парчета, всяко от което върши конкретна работа. Ако имаме твърде много класове, разделяме ги по неймспейсове. Ако имаме твърде много неймспейси - разделяме ги на отделни проекти. 
	Името на класа трябва да е като името на файла.cs Ако имаме два файла с еднакви имена - разделяме с папки. Това не променя неймспейсите им. Компилаторът се интересува само от неймспейса, а не от това в коя папка е файла. Но е добре структурата като папки трябва да отговаря на неймспейса. 
	Трябва да си изтеглим програмата StyleCop - За правилен/качествен програмен код (по Майкрософт). Къде да се пишат using... дали отгоре, или в неймспейса. Това е според екитъп, с когото работим, както се разберем. И двете работят. Някъде пък е прието полетата да започват с _ . Идва от някои езици. 
	Документацията в кода - /// - три наклонени черти. Описват какво правим в кода. Това може да се използва от другите програмисти, ако ние сме си написали документацията. Там като се напише GenericList<> излиза подсказка, какво е това. Според StyleCop всяко едно нещо трябва да си има документация. Т.е. такова описание. Обикновено се описват нещата, които са трудни за разбиране. Някакъв тежък за схващане алгоритъм, или нещо подобно. В StyleCop - а отменяме "да ни се кара" за документация в настройките. А останалите да остаат. По този начин ще се научим как трябва да се пише качестевн код. 

Индексатори. Можем да правим собствен индексатор, който да сетва или да връща данни в собсвтената колекция. Синтаксисът е както пишем методи и пропертита, т.е. аналогично е: public int this [int index] {...}

Важно!!! Когато имаме колекции (масиви, листове) в полетата, в конструктора трябва да се инициализират/инстанцират с new ...;



Записки по време на лекцията на Ивайло от 13.03.2015 г.

Преговор първите 2-25 мин. 

Създаване на класове - котки, собственици, енумерация, 

Статичните неща излизат с името на класа. 
Докато нестатичните - през инстанцията - конкретната котка. 
Всички статитчни неща не може да се извикват от this.  Могат да се извикват през името на класа. 

Автоматично проперти не трябав да правим, когато искаме да валидираме някакви данни. Те се валидират през пропертито. 
Иначе когато не валидираме, - правим автоматично проперти. Правим само автоматични пропертита, а ако ни трябва валидация, тогава пришем и полета и имаме неавтоматични пропертита. 
Всеки един клас трябва да знае възможно най-малко за  другите класове. 

Статичните - когато за първи път се използват, тогава се зареждат в паметта. А инстанционните се съдават когато се създава инстанцията. 

Прави статичен клас Принтер. В него не може да има нестатичин неща. Обикновено повечето класове не искаме да са статични. Статичните си живеят през цялото време на изпълнение на приложението. 

Структурите са стойностни типове данни и се държат като примитивни типове данни. Structure - value type; Class - refernce type;
структурите винаги имат конструктор без параметри. Да се използват когато трябва да пазим някакви данни. Всяко нещо, което има някаква логика, да е клас, а не структура. Ако променяме някаква структура, тя се копира, като примитивни данни. 


Продължение на лекцията:

Generics  List<int> Шаблонни класове, които приемат всякакъв вид данни. List<T>  когато се използва ,се казва какъв клас се използва. 
Позволяват да се създаде шаблон и да има цялата логика на съответния клас generic.  Клас , който очаква някакъв тип данни при инстанциране. И <T> се замества със съответните типове данни. Има и някои ограничеиня. Този елемент от тип Т се държи като обект. Не могат да се сравняват, и т.н. Може да има и повече от 1 тип данни в <>.  Може да се ограничи какво да е Т: <T> where T: Class, int, Cat
Generics могат да бъдат ограничение по този начин (със синтаксиса  :...) и да работи с тях. 

Освен това може да имаме дженерик методи. 

При неймспейсите, с точки прави под немспейси. За допълнително специфициране на нещата. Когато класовете станат много, разделяме с неймспейси. Ако един клас стане дълъг, разделяме на под класове. Всеки клас да е в отделен файл. И класа се казва с името на файла. Структурата на папките трябва да отговаря на структурата на неймспейсите. 

Style Cop - да го изтеглим и поставим в VS. Това са правилата на Майкрософт за качествен програмен код. след /// се добавя документация за кода. 

Как да си направим собствен индексатор. Индексаторите се пишат като проперти. Проверка за валидност. има 
Прави нещо като дикшънъри, и демонстрира индексатор върху него.  Tuple...  по-добре е да си правим собсвен клас и да не го ползваме. Прави дженерик Tuple.

Atribute - [ ] те не променят нищо по кода. Но дават допълнителна информация за този код. Поставят се горе в началото на класа. Тази информация се пази в крайния компилиран код. 




Записки по четвърта лекция in time

При наследяване на конструктори, трябва да сочат към един. Това е най-добрия вариант. : base () - сочи към конструктор от бащиния клас. this() - сочи към конструктор от текущия клас. Без параметри е дефолтния конструктор. 

Всеки клас може да наследява точно 1 клас. Докато един клас може да се наследява от много класове. 

IEnumerable, .. интерфейси. Асембли - включва .exe и .dll

Структурите не могат да бъдат наследявани. seald  - клас който не може да бъде наследяван и разширяван. //

Имаме интерфейси, с които може да става множествено наследяване. 

Статичните методи и конструктори също се наследяват. 

virtual, abstract;  virtual метода/пропертитата е нещо което му се дава едно тяло, и ако иска наследника може да го презапише. Т.е можем да ги overridе - ваме. 

Абстракция - да не е конкретно, да е общо. За екстеншън метод . който може да се наследява?

public static void ForEach<T> (this IEnumerable<T> items, Action<T> action)
{
foreach (var item in items) { action(item); }
}
numbers.ForEach(x => Console.WriteLine(x));

Абстракция може да има на различни нива - на ниво методи, класове, .... Абстракиця при класове: Наследяване, Абстрактни класове, Интерфейси. Публичния интерфейс на един клас е всички публични методи, пропертита .....

interface IShape   дава само методите на класовете, които го наследяват. Класовете, които ме имплементират, трябва да сложат 
Интерфейсът Казва кои методи и пропертита трява да има в класовете, които го наследяват. т.е. трябва да имплементираме в нашите класове, които наследяват този интерфейс. В интерфейса имаме само пропертита, методи, евенти!!!  Всички членове са public. И задължително не трябва да има тяло. Интерфейсите ни дефинират множествено наследяване. Един клас наследява точно 1 клас, но може да наследява много интерфейси. Дава по-голямо флексибилити. 

На променлива от някакъв тип можем да присвоим стойност от типове от негов наследник. Полиморфизъм! Благодарение на полифорфизма,

Когато поставим abstract в пропертитата - казваме че искаме наследниците класове да ги имплементират. На тези методи е задължителна имплементацията. Ако маркираме класа като abstract то и при него не ги имплементираме. Когато класа е abstract не може да се дава на него new т.е. не можем да му правим инстанция. В статичния клас всичко трябва да е имплементирано. 
Абстрактен клас - Не е нужно да има абстрактни членове, за да е абстрактен класа. Правим го абстрактен, за да можем да го наследим, и да укажем кои методи по-надолу по веригата трябав да бъдат имплементирани. 

Интерфейсите ни дават множествено наследяване!!! Абстрактен клас - той си е клас, може само 1 наследяване на него да правим. 

Клас диаграми - и при тиим уърка да показваме. Но сега classDiagram  - .cd е разширението на файла Можем да правим схеми, Диаграма на наследявване на класовете, Показва ни и пропертита и методи. Можем и да добавяме нови пропертита. Можем да добавяме и класове. и да си направим схемата, а след това Можуем с тулсовете да правим наследявания. Клас диаграма - правим класове, после им добавяме пропертита, методи, и т.н. Като видим че някои клас има общи неща, може да ги поставим по-нагоре. Можем и от това да си генерираме класове. 


Енкапсулация - публичния интерфейс, който даваме на външния свят. 

В секъра и гетъра се слагат валидатори, за да може кодът да работи коректно. Когато ще имаме валидация, трябва да имаме поле. за да се спре некоректното сетване, правим поле private и през value проверяваме дали са коректни данните. С енкапсулацията успяваме да държим нашите дани коректни и валидни. Т.е. правете пропертита! автоматични! ако ни трябва валидация, на по-късен етап си екстендваме с полета и валидиране в пропертитата. В конструктора навсякъде където можем, или в методите, да използваме пропертито. 

Сетъра на пропертито - мястото където се валидира всичко - 



Бележки по четвърта лекция други - при преглеждане на видеото

Прави се тестващия клас с Main метода като в него ще пробвам нещата. Прави си папка Models в която поставя класовете - отначало Person - с 2 автоматични порпертита - Email, Name; После си прави клас (пак в папката) Student - наследява Person; И в него нищо няма. Отива в тестващия клас - прави инстанция на студента. Макар че в Student няма нищо, тъй като той наследява Person, може да му направи инстанция, която ще има Еmail, Name; За да го познава обаче, Не добавя горе в кода using ScoolSystem.Models; - в тестващия клас, а променя неймспейсите на всички класове като на тестващия. 

Общите неща изнасяме в един базов клас, вече след това, когато се разминават пропертитата, правим нов клас, наследяващ базовия. Поема всичко като пропертита и методи от базовия, но си има и свои специфични пропертита, които само той си ги има. Така че в Student класа добавя пропертито StudentID. По същия начин постъпва с учителя, После създава UniversityProfessot, кото е под Teacher, т.е. наследява Teacher; и т.н. си направих цялата схема. 

Прави един интерфейс - през клас. С име IPerson. Повечето интерфейси са публични. В тях пише методи и пропертита, но не им дава Access Modeifier - без public, private ... Смята се, че всичко е public, също void метода. На пропертитата маха сетърите, тъй като там те трябва всичко да е public. В интерфейса да няма думата public.

Ако интерфейсът не ни задължава сетъра да го има, правим в наследника - Person сетъра private. Като имплементира Walk гърми, ако няма пропертитата с get, set; Прави конструктор с име и email. Но тогава гърми, защото няма празен (без параметри) конструктор. То гърми, защото при наследяването единствено не се предават конструкторите. Ако нямаше наследяване, нямаше да гърми, тъй като ще си направи по подразбиране празен конструктор. Но сега вижда, че Парент класа, т.е. Person няма конструктор. И дава грешки в неговите наследници - казва, че нямат празен конструктор. 
	Като тръгна да правя конструктори в Student, Teacher, Employse прави конструктора с 2-3 параметъра, но добавя след това : base(name, email) т.е. да използва конструктора на родителския клас. Тук прави конструктор с параметри, но след наследяването тялото на конструктора е празно. Мнаго пъти в пропертитата сетъра е private. По този начин пропертито е почти readOnly и се спазва принципа на капсулация-encapsulation. 
	Ако някои от децата на Person наследи директно интерфейса, трябва да му добавим горе using ... .Тогава пак иска да се имплеметират онези неща - от интерфейса - Name, Email, Walk. Автоматично ги добавя след Ctrl-. 
	Важно! Йерархията се построява, като освен че наследяват Person, се дава и че наследяват IPerson. Тогава пропертитата, които се искаха да ги има в някои от класовете, за да се билдне, могат да се изтрият, тъй като се имплементират от първия наследник на интерфейса - Person. Става дума за пропертитата, които стават подчертани със зелена вълнообразна черта след горното наследяване. 
	Интерфейсът е структурата как трябва да изглежда нещо, докато имплементацията е в наследниците. Наследяват се атрибути (пропертита и полета) и методи, но не се наследяват конструктори. Когато при наследяване в конструктор, се преизползва този на родителя, се пише : base(name, email), докато ако се преизползва този от текущия клас се пише   this(name, subject).  Детето клас наследява base класа/родителя/; класа имплементира интерфейса; наследникът интерфейс разширява (extends) base interface (екстендва) базовия интерфейс. 
	Важно!!! когато искаме да можем да сравняваме двама студенти, в името на класа Student  добадяме също така Student : IComparable<Student> . Веднага излиза да имплементираме метода public int CompareTo(Student other)
	Кога правим наследяване и кога правим проперти? Имаме примерно клас животно и клас сърце. Задаваме си въпроса "is a" (т.е. дали животното е сърце) - отг. Не. Тогава не го наследява, а сърцето е само като проперти. Другият въпрос който задаваме е "has a" (дали животното има сърце). Да. Тогава е проперти. Когатот правим проперти с propg Tab Tab автоматично проперти, при което сетъра е private. Добре е да е така. 
	При интерфейса - всичко което е в него, трябва да бъде имплементирано. Обаче някои членове на интерфейса могат да бъдат inaccessible (hidden). През this могат да се достъпват методите и пропертиатата на текущия клас, докато през base се достъпват тези на родителския клас. Един клас може да наследява само един клас, но няколко интерфейса. 
	Важно! По дървото с наследявания от даден обект - какви интерфейси наследява, може да видим какви методи трябва да имплементира, ако наследи някой от тези интерфейси. F12 клавишът дава достъп до това дърво. Пишем в Main метода един лист List<int> list = new List<int>(); И върху List - a F12  - дава дървото с наследявания от този лист. 
Т.е. Ако искаме да работим с нещо, което искаме да има Add, Clear, Contains, CopyTo, IsReadOnly, то то трябва да наследява ICollection<T>. и оттам нататък да си имплементираме тези методи. 
	С :base(x) се извиква базовия конструктор и му се подават някакви параметри. Chaild класа разширява функционалността на Parent класа, като взема цялата негова функционалност. Ако класът, който наследяваме има повече от 1 конструктор, то можем да подадем след base() някой от тях и мачването е в зависимост от подадените параметри. В базовия клас единия конструктор извиква другия с : this().
   Не само при конструкторите, но и при използване на методите на Парент класа, може вместо this. да използваме base. По този начин може да извикваме метод от Парент класа в текущия Child клас или в някой негов метод. 
	Всичко в интерфейса е публично. Ако искаме да има private set-er в наследниците, тук трием set; 

Абстрактният клас е нещо междинно между клас и интерфейс. Имаме някои неща имплементирани, други не. Остават за неговите наследници. Преди да направим инстанция от нещо всичко трябва да е имплементирано. Ако класът е абстрактен, всичко да е имплементирано. Ако не в него, то в наследниците. От абстрактния клас не може да се прави инстанция. 
	Важно! Винаги се стремим да работим с най-високото ниво на абстракция
List -> IList -> IList<T> -> IEnumerable -> ICollection<T>

Енкапсулация - Всичко, което не е в интерфейса трябва да е скрито. private -> protected -> interna -> protected-internal -> public. Това е реда на постепенно разкриване. Но по възможност всичко трябва да бъде максимално скрито. Ако искаме нещо да се вижда отвън, добавяме го в интерфейса и оттам нататък го имплементираме в класовете. Иначе всичко което не е в интерфейса трябва да е или private, или protected. Ако нямаме валидация в пропертито, пишем си го автоматично проперти, и не го мислим за field, т.е. правим го без поле. 

Бележки по 4 лекция при преглеждане на демата - продължение работата по 4 лекция

При една структура от класове - обяснения за абстрактните класове - Най-отгоре е абстрактния клас, наследяващ IComparable<Animal>. В абстрактния клас Animal се задават абстрактни полета с автоматични пропертита (само пропертита има) които са абстрактни и ще бъдат имплементирани задължително в наследниците. Неабстрактен метод - public override string ToString(){ ;}  И има метод, който идва от наследяването на интерфейса и е тук имплементиран: public int CompareTo(Animal other){ return this.Speed.CompareTo(other.Speed);} Ако в абстрактния клас има неабстрактни пропертита автоматични то те не се имплементират по-надолу. Смята се че са готови. 
	В следващия след Animal също абстрактен клас Cat : Animal  има автоматично проперти и абстрактен метод, който ще се имплементира по-надолу в наследниците. Всичко което е имплементирано (не е абстрактно) в по-горните абстрактни класове и имплементирано в неабстрактните горни класове (от които има наследяване), няма да се прави по-надолу. Когато по-надолу се прави нещо, посочено по-горе като абстрактно, то то се override - ва. В класа Cat не са имплементирани абстрактните пропертита от Animal GetName и Speed, както и абстрактния метод SayMiau от Cat, поради което те и трите се имплементират с думата override в класовете на наследниците на Cat -> Kitten и TomCat. Тъй като по тази верига надолу няма други наследници, всичко, което по-горе е заявено като абстрактно проперти  или метод, трябва да се оверрайдва. 
	Друг е случаят при Cheetah и  Turtle. Те нямат междинен абстрактен клас като Cat, а са преки наследници на Animal. Ето защо трябва да имплементират всичко абстрактно, заявено оттам. (with override): GetName, Speed.
	Така по двете вериги не остава нищо, което да не е оверрайдвано.  Абстрактните класове не могат да се инстанцират. (с new).

Бележки по пета лекция - при преглеждане на видеото - Ники

Стремим се да работим с максимално абстрактен клас, да използваме неговите методи, за да е всичко по-общо, за да е кодът по-преизползваем. Ако ни трябва само foreach използваме  IEnumerable; ако ни трябва вземане по индекс вместо List  използваме IList.  
Абстрактни методи и полиморфизъм.  Виртуален се прави метод от базовия клас, на който даваме възможност да се овъррайдва при наследниците с ключовата дума virtual и да му се смени поведението. Ако методът не е абстрактен или не е виртуален, то ние не можем да го променим в наследяващите класове. Като правим метода абстрактен, може да сме сигурни, че нитой не може да направи от него инстанция. По този начин ще ограничим използването на кода по начин, който искаме. Друг вид клас, освен абстрактния е с думата 
sealed ->  Ако искаме никой да не може да наследява този клас, му поставяме този идентификатор. public sealed class myClass{....}.
abstract -> искаме всички негови методи да се имплементират при наследниците и никой да не му прави инстанция;  private -> искаме никой да не вижда променливата, която има вътре. Когато класът/базовият/ е абстрактен обаче, аз мога да направя инстанция от неговия тип, но всъщност от типа на наследяващия го клас: public abstrac class Control;   public class Button : Control;  In Main(): 
Control control = new Button();   на променливата от тип Control мога да направя присвояване от всеки от един от наследниците на базовия клас. Променливата control ще си има методите от базовия клас, ще може да се рисува. (Draw() метод има). Но ако сложим друг метод в Button, примерно Click(); то този метод няма да е достъпен за control. Т.е. тази променлива ще си има само методите на базовия клас. Сега правим овъррайдване на метода Draw() в Button класа. Ако го оставим по подразбиране след думата override там в тялото на метода имаме кодът:  balse.Draw(), т.е. извиква се този метод от парент класа. Но ние го овъррайдваме/променяме неговото поведение в чайлд класа. Тогава  control.Draw()  ще  извика и изпълни новия метод в чайлд класа Button(); Ако обаче в тялото на оверрайдвания метод остане balse.Draw(), то след изпълнението на другия код, ще се изпълни и този метод, извикан от парент класа. Ще се изпълнят и двата. И това е идеята на полиморфизма. Ако променим поведението /махнем balse.Draw()/ и пишем друг код, то ще се изпълни той. Т.е. ще се изпълни методът от наследника, макар че променливата е от тип базовия клас, тъй като тя е дефинирана като инстанция на наследника. 
Ако променливата от тип базовия клас я направим с инстаниця от друг наследник на базовия клас, то тя ще изпълнява методите на другия чайлд клас, чрез инстанция на когото е дефинирана. Така тази променлива от тип базовия клас  contrl  може да има различно поведение, в зависимост от това чрез инстанция на кой от наследниците е дефинирана. Това е полиморфизма. 
	Друго: Ако скрием метод, т.е. при наследника го дефинираме без ключовата дума overrde т.е. той се казва по същия начин, но не е овернайдван, в такива случаи полиморфизмът не работи. Този метод си остава отделен, за класа в който е дефиниран и си работи с него.  Т.е променивата се държи полиморфно, когато в базовия клас методът е virtual и е override-ван в чайлд класа. Когато обаче методът в базовия клас не е virtual,  и го има със същото име в чайлд класа без овъррайдване /т.е. ние сме го скрили/, тогава се губи полиморфизма и променливата си работи само с метода от базовия клас. Отдолу се получава worning  - жълт триъгълник в Еррор листа на Вижуъл студио. Предупреждава, че в наследника сме скрили нещо от базовия клас.  Тогава, когато искаме нарочно да го скрием в чайлд класа, вместо ключовата дума override се използва ключовата дума new преди (void Draw()). И няма да има worning. Така можем да направим и в двата класа наследници, за да няма worning. Но променливата продължава да не се държи полиморфно. Така, че за да се държи тя полиморфно, трябва в базовия клас методът да е  virtual и в базовия клас да се overrde-не.  
	Важно!! Прави си един масив от тип базовия клас. В него поставя елементи от различните му наследници, т.е. в него има разнородни по тип имплементации/обекти от тези типове. Накрая му прави foreach и всеки елемент си извизква своя конкретен метод за изчертаване и прави това, което искаме. Като код е така:   Тук имаме нагледен пример за полиморфизъм:
	Figure[] figures = { new Line(), new Circle(), new SpecialFigure(), new Square(), new Line()};  foreach(f in figures){ f.Draw(); cw...;} 
Можем да си направим абстрактен метод. Абстрактните методи са виртуални. Те са методи, на които можем да променим поведението, но са методи, които нямат имплементация в базовия клас. Нямат тяло в базовия клас. Всички наследници на този клас трябва задължително да имплементират абстрактния метод. С ключовата дума overrde трябва да са в чайлд класовете.  Когато имаме абстрактен метод или абстрактно проперти, класът също трябва да е абстрактен. public abstract class Control { }. Абстрактните класове могат да имат и виртуални методи, и методи, които да си имат поведение. Последните такива, които не са абстрактни, ще ги има всеки един от наследниците, няма да може да ги променя. Само ако са виртуални, ще може да ги променя, но не е задължително. Задължително е само овъррайдването/имплементирането с override/ на методите, маркирани като абстрактни. Овъррайдването при абстрактните методи е отново същото. Разликата е само, че абстр. метод няма тяло. Този начин позволява полиморфизъм. Докато виртуалния метод позволява овъррайдване в наследниците, без то да е задължително, абстрактния метод задължава наследниците да овъррайдват метода. 
	Интерфейсите са неща, които имат описание само на абстрактни методи. Т.е. списък от методи, които наследникът трябва да имплементира задължително. Абстрактните класове са комбинация между интерфейсите и нормалните класове.  Хем имат поведение, хем имат неимплементирано поведение, задължително за наследниците. Виртуалните методи могат да бъдат "скривани" с ключовата дума new вместо overrde. Избягваме да използваме такова скриване. По-добре да го направим с друго име. 
	Ключовата дума base.  ни позволява да извикваме метод от базовия клас, който наследяваме, но който не е абстрактен. Ако извикваме същия метод в тялото на който се намираме с this, получаваме безкрайна рекурсия и StackOverflowException. Но ако извикаме базовия метод  base.Draw(),  няма да има такава рекурсия. Не виртуални и не абстрактни методи не можем да овъррайдваме. 
Статични методи не можем да овъррайдваме. Статичните неща като цяло трябва да избягваме. Така отново на полиморфизма - това са нещата с които го постигаме - абстрактни, виртуални методи и овъррайдване. Полиморфизмът ни осигурява, че докато нашия код работи, ще ни бъде избран чрез конкретен наследник и  конкретен обект, който ще бъде присвоен на променлива от базов тип, конкретния обект от  този базов тип който ще бъде извикан през интерфейса на базовия клас. 
	Кохезия и Cohesion and Cupling 
Принцип на строга кохезия. Доколко кодът който създаваме, методите които пишем имат една единствена цел, името им описва тази цел. Те правят това, което описва името им. Не повече, не по-малко. Имат ясна цел. Когато един метод започва да прави повече от едно нещо, разделяме го на отделни методи. Когато в един клас започват да се случват повече от 1 неща, разделяме го на два класа. Това се нарича строга кохезия. Класовете, освен това че трябва да са добре именувани, трябва да имат много ясно определена функционалност. И един метод прави едно нещо, един клас върши една цел, върши една работа. Съответно класа да има добра комплексност. Един клас да не е за много дейности отговорен, а само за една. Ако е необходимо се разделя на повече класове. Добра кохезия има Math класа.  Когато имаме три отделни класа с ясни цели е по-добре от един клас, в който са всичките тези неща. 
	Друг измерител за качеството на кода е Coupling. Описва доколко отделните елементи на нашия код - интерфейси, класове, методи, доколко те са обвързани с накакви други методи, класове и т.н. Колкото повече неща имат достъ до един клас, толкова по-лошо. Ако искаме да го преместим на друго място, колко други неща с него трябва да се поместят. Лошо е, когато завлича със себе си много класове. Ако завлече 2-3 интерфейса, добре, ако завлече 20 класа - лошо. Не са разкачени другите класове от него. Това е мярка за разкаченост на класовете един от друг. Каплинга трябва да бъде луус каплинг - максимално трябва да са разкачени отделните неща/класове. Постига се с депендване на интерфейси. Когато можем да подменяме лесно компоненти в една ООР система, тогава е добре.  Имаме луус каплинг Loose Coupling. Другото е лош каплингг - Tight Coupling.  
	Каква е работата, че трябва да разчитаме на отделни интерфейси, вместо на конкретни класове. Ако имаме някаква архитектура от класове, която искаме да разкачим една от друга. Дефинира интерфейс, който декларира общо действие. Той се наследява от класовете, отговорни за подобни дейсвтия, но разделя функционалността им през интерфейса.  Принтера не е вече закачен за репорта, а може да принтира и други работи. Вече са разкачени благодарение на този интерфейс IPrintable или др. име. Сега ако преместваме Принтера, местим Принтера и Интерфейс; Ако местим Репорта, местим Репорт и Интерфейс. Разкачени са. Прави пример за рефактуриране на кода, около 1ч 40 - 47 мин. от началото (т.е. към края на лекцията). Получаваме код, който е много разкачен, който може да се разширява. Спагети кодът е когато правим една промяна в един клас, ще трябва да бръкнем в още 5 класа. Или при местене. 
Когато за една промяна бъркаме 2 пъти в един и същи клас, то той трябва да бъде разкачен на отделни класове. 	 


Продължение на лекция 6 Записки по лекция 6 след 1ч 6мин.

GetType() - ни дава възможност кодът да се самоизследва. Той е т.н. рефлекшън, с други думи да изследваме рън-тайм какво е писано по кода. т.е. докато програмата работи да се изследва сама, и върху всеки тип данни да вземаме някаква информация. Изкарва всички методи на конзолата. По този начин, чрез този рефлекшън с GetType можем да изследваме някои неща вътре в паметта. 

Операторите is и as са да правим сравнения дали един тип данни са друг тип данни. Ползва се когато имаме полиморфизъм, проверява се дали даден обект е инстанция на някакъв обект или на друг обект. 
	Ако имаме един интерфейс IAnimal и котката го наследява, тогава проверяваме с този метод дали котката е котка, и ако е направи това, ако не е - направи друго. Проверяваме дали един тип данни е някакъв друг тип данни. 

	as оператора каства. var secondAnimalAsDog = (Dog)secondAnimal; //ще гръмне, докато ако е със as
	           var secondAnimalAsDog = secondAnimal as Dog;// ще мине и ще отпечата празен ред при cw... i.e. null


Трябва да си изтеглим един продукт ILSpy - ако отворим някакъв компилиран код, примерно някакво .exe Ако го отворим през ILSpy  той ще ни позволи на разгладема IL кода на това нещо. 

Операторът == сравнява местата в паметта на съответните обекти и никога няма да каже true; Ето защо трябва да се овъррайдне за други обекти, освен числата











Записки подготовка за изпит

Здравейте Колеги.
Може ли някой да  разясни или да помогне при задачи когато имаме да добавим функционалност към дадено API... 
как  да започнем ? Такова разширяване... Някакви насоки .... трикове ... .....

Обикновено имаш един клас, който не можеш да пипаш и управлява "командите", които получава програмата  (инпута) с няколко метода, в които има суич с вече зададени по 1-2 кейса.
Първата и основна стъпка е да си направиш нов клас, който наследява и разширява въпросния, в който да оувъррайднеш тези методи със суичовете, като за вече направените кейсове да викаш базовия метод с получените параметри, а за новите класове, които създаваш според условието, да добавяш кейсове вече в твоя нов клас и някъде в мейн метода да създаваш инстанция на твоя енджин вместо тази, която е зададена поначало.
Например за Trade and Travel от изпита от декември 2013 имаш един клас InteractionManager, който в мейн метода се използва така: 
var engine = new Engine(new InteractionManager());
            engine.Start();
Ти трябва да направиш един клас (аз съм го кръстил Extensions, но името няма значение), който наследява InteractionManager и вече в мейн метода да работиш с него:
var engine =newEngine(newExtensions());
             engine.Start();
   
Можеш да погледнеш ТУК как съм го направил:
преди един час от   topalkata (1521 точки)


































