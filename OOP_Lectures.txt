Бележки по първа лекция: 

Когато въвеждаме константа public const double PI=стойност, трябва да въведем числена стойност. 
Когато въвеждаме рийд онли константа не е нужно да въвеждаме стойност, а само я декларираме с име: public readonly double Size;
В конструктора въвеждаме нейната стойност. Няма проперти. След като веднъж се въведе, стойността не може да се променя. Като const
В Main() се извикват през името на класа с главна буква! Както и всичко статично! При създаване на нова константа, тя се създава като рийд-онли константа през името на класа само! т.е. константа от тип името на класа!
	Важно! Стойността на рийд-онли константата след създадена инстанция (т.е. нова константа през името на класа) се достъпва през инстанцията с точкова нотация и името на тази константа в класа:  c.Size; dou.Size; Така се извиква и отпечатва! 

Внимание! В Сетера се проверява value. Т.е. всички проверки за валидация трябва да бъдат по отношение на "value"!!! Накрая се сетва стойността на съответното проперти с израза this.name = value; (or age, или нещо друго, за каквото е пропертито). 

В конструктора има само public.. и името на класа и () със или без параметри. В пропертито има public.. и int/string/.. С гл.буква
В кода когато пишем this. след това пропертито е с Главна Буква!!! Защото е името на съответното поле, а не неговата стойност. За да могат да се запишат с главна буква в конструктора, т.е. да се минава през пропертито (и съответно да може да се извърши съответната валидация на входните данни) трябва преди това да са направени пропертитата (при тях имената са с гл. букви). Следователно: правим си полетата private (ако има такива); Правим си пропертитата (get; set;), евентуални валидации; И тогава преди тях си правим конструкторите; След тях ако има си правим методите. Валидациите могат да бъдат изнесени накрая в отд. методи. 
След this. с главна буква е в конструкторите; иначе може и с малка буква. 

При енумерациите. Прави се инстанция без new и се присвоява през името на енумерацията съответната конкретна стойност. 
DayOfWeek day = DayOfWeek.Wednesday;

Валидация на данните в пропертитата. След това в Main() също при правенето на инстанции на класа - през try - catch + Exception ex може



Бележки по втора лекция

В конструктора за някакво свойство, което е зададено автоматично, задава стойност числена, с главна буква е и го няма в параметрите на конструктора. Ако го има в параметрите, тогава не задава числена стойност, а от полето. 

Когато използва друг клас/енумерация(цвят на котките) в базовия (котка) прави проперти от тип енумерацията с главна буква и get; set; Това свойство може да си вкюлчи в конструктора с малка буква. 
	Добавя си в полетата private List<Cat> cats; и тази колекция инициализира в конструктора. Преди това си прави метод за добавяне на котки към List<Cat> cats:
public void AddCat(Cat cat, string name)
{
	if(this.cats.Contains(cat))
	{
		throw new ArgumentException("...");
	}
	cat.Name = name;
	cat.Owner= this;
	this.cats.Add(cat);	
}				Но сега за да работи трябва да добави листа в контруктора. Задължително там трябва да кажем: this.cats = new List<Cat>(); 
	Ще го направя като проект по лекцията на Ивайло във VS. 

Когато в полетата отгоре се декларира масив, или някаква лист колекция, тогава в конструктора задължително с това име (декларираното горе) се дава образуване на инстанция с new ... . В статичния контруктор при статични масиви може да има и цикъл с инициализацията на този масив. 

Интересен начин на използване на подполетата е дадено във демото DefiningClass-2, 2.Structures: /така прави цвета/в 
public override string ToString() -> "surface(#{4:X2}{5:X2}{6:X2}), border(#{7:X2}{8:X2}{9:X2})", this.SufaceColor.RedValue, this.SurfaceColor.GreeVlue, this.SurfaceColor.BlueValue и същото за 7, 8 и 9 но BorderColor.
	Важно! Навсякъде където има пропертита, а и в методите ползва this.

	Важно!!! Всички неща, които искаме да са използват, има ги в полетата горе, за да работят трябва да се инстанцират в конструктора. Иначе няма да работят!!! Горе има: private List<Cat> cats; В конструктора трябва да добави: 
this.cats = new List<Cat>(); т.е. да направи инстанция на листа (или масива). Тогава вече той ще работи. Може би затова не мога да използвам battery и display при GSM-a. от първото домашно. 
В конструктора пишем this.Name = name; С главна буква, за да мине през пропертито и да изпълни валидацията. Там където нямаме полета - може автоматично проперти за това свойство. Иначе с поле и с валидация. Пишеш само автоматични пропертита, ако ти трябва валидация - с полета и неавтоматични пропертита. 
	До тук беше преговор от първата лекция - това за котките. 

Статични неща - могат да се сетват на: Fields, Properties, Methods, Events, Constructors. Статичното е общо за целия клас и се достъпва през името на класа (с гл. буква); Нестатичното е свързано с инстанцията и се достъпва през нея (след като се направи спооред конструктора с new ... . 
	Ако един клас е статичен, нищо инстанционно не може да съществува в него и не можем да създаваме такова. В общия случай искаме нещата да не са статични. 

Структури - Стойностни типове данни и се държат като примитивни типове данни. Структурата се копира, докато класа се подава по референция. Структури се използват когато имаме да пазим няколко данни. Координати на точка, и др. Когато обаче имаме някаква логика - да е клас. Иначе няма голяма разлика между тях class and struct, но в памета се държат по различен начин. Всички примитивни типове данни са структури. Само стринга е клас, но се държи като примитивни данни.































Записки по време на лекцията на Ивайло от 13.03.2015 г.

Преговор първите 2-25 мин. 

Създаване на класове - котки, собственици, енумерация, 

Статичните неща излизат с името на класа. 
Докато нестатичните - през инстанцията - конкретната котка. 
Всички статитчни неща не може да се извикват от this.  Могат да се извикват през името на класа. 

Автоматично проперти не трябав да правим, когато искаме да валидираме някакви данни. Те се валидират през пропертито. 
Иначе когато не валидираме, - правим автоматично проперти. Правим само автоматични пропертита, а ако ни трябва валидация, тогава пришем и полета и имаме неавтоматични пропертита. 
Всеки един клас трябва да знае възможно най-малко за  другите класове. 

Статичните - когато за първи път се използват, тогава се зареждат в паметта. А инстанционните се съдават когато се създава инстанцията. 

Прави статичен клас Принтер. В него не може да има нестатичин неща. Обикновено повечето класове не искаме да са статични. Статичните си живеят през цялото време на изпълнение на приложението. 

Структурите са стойностни типове данни и се държат като примитивни типове данни. Structure - value type; Class - refernce type;
структурите винаги имат конструктор без параметри. Да се използват когато трябва да пазим някакви данни. Всяко нещо, което има някаква логика, да е клас, а не структура. Ако променяме някаква структура, тя се копира, като примитивни данни. 


Продължение на лекцията:

Generics  List<int> Шаблонни класове, които приемат всякакъв вид данни. List<T>  когато се използва ,се казва какъв клас се използва. 
Позволяват да се създаде шаблон и да има цялата логика на съответния клас generic.  Клас , който очаква някакъв тип данни при инстанциране. И <T> се замества със съответните типове данни. Има и някои ограничеиня. Този елемент от тип Т се държи като обект. Не могат да се сравняват, и т.н. Може да има и повече от 1 тип данни в <>.  Може да се ограничи какво да е Т: <T> where T: Class, int, Cat
Generics могат да бъдат ограничение по този начин (със синтаксиса  :...) и да работи с тях. 

Освен това може да имаме дженерик методи. 

При неймспейсите, с точки прави под немспейси. За допълнително специфициране на нещата. Когато класовете станат много, разделяме с неймспейси. Ако един клас стане дълъг, разделяме на под класове. Всеки клас да е в отделен файл. И класа се казва с името на файла. Структурата на папките трябва да отговаря на структурата на неймспейсите. 

Style Cop - да го изтеглим и поставим в VS. Това са правилата на Майкрософт за качествен програмен код. след /// се добавя документация за кода. 

Как да си направим собствен индексатор. Индексаторите се пишат като проперти. Проверка за валидност. има 
Прави нещо като дикшънъри, и демонстрира индексатор върху него.  Tuple...  по-добре е да си правим собсвен клас и да не го ползваме. Прави дженерик Tuple.

Atribute - [ ] те не променят нищо по кода. Но дават допълнителна информация за този код. Поставят се горе в началото на класа. Тази информация се пази в крайния компилиран код. 
