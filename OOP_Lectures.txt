Бележки по първа лекция: 

Когато въвеждаме константа public const double PI=стойност, трябва да въведем числена стойност. 
Когато въвеждаме рийд онли константа не е нужно да въвеждаме стойност, а само я декларираме с име: public readonly double Size;
В конструктора въвеждаме нейната стойност. Няма проперти. След като веднъж се въведе, стойността не може да се променя. Като const
В Main() се извикват през името на класа с главна буква! Както и всичко статично! При създаване на нова константа, тя се създава като рийд-онли константа през името на класа само! т.е. константа от тип името на класа!
	Важно! Стойността на рийд-онли константата след създадена инстанция (т.е. нова константа през името на класа) се достъпва през инстанцията с точкова нотация и името на тази константа в класа:  c.Size; dou.Size; Така се извиква и отпечатва! 

Внимание! В Сетера се проверява value. Т.е. всички проверки за валидация трябва да бъдат по отношение на "value"!!! Накрая се сетва стойността на съответното проперти с израза this.name = value; (or age, или нещо друго, за каквото е пропертито). 

В конструктора има само public.. и името на класа и () със или без параметри. В пропертито има public.. и int/string/.. С гл.буква
В кода когато пишем this. след това пропертито е с Главна Буква!!! Защото е името на съответното поле, а не неговата стойност. За да могат да се запишат с главна буква в конструктора, т.е. да се минава през пропертито (и съответно да може да се извърши съответната валидация на входните данни) трябва преди това да са направени пропертитата (при тях имената са с гл. букви). Следователно: правим си полетата private (ако има такива); Правим си пропертитата (get; set;), евентуални валидации; И тогава преди тях си правим конструкторите; След тях ако има си правим методите. Валидациите могат да бъдат изнесени накрая в отд. методи. 
След this. с главна буква е в конструкторите; иначе може и с малка буква. 

При енумерациите. Прави се инстанция без new и се присвоява през името на енумерацията съответната конкретна стойност. 
DayOfWeek day = DayOfWeek.Wednesday;

Валидация на данните в пропертитата. След това в Main() също при правенето на инстанции на класа - през try - catch + Exception ex може



Бележки по втора лекция

В конструктора за някакво свойство, което е зададено автоматично, задава стойност числена, с главна буква е и го няма в параметрите на конструктора. Ако го има в параметрите, тогава не задава числена стойност, а от полето. 

Когато използва друг клас/енумерация(цвят на котките) в базовия (котка) прави проперти от тип енумерацията с главна буква и get; set; Това свойство може да си вкюлчи в конструктора с малка буква. 
	Добавя си в полетата private List<Cat> cats; и тази колекция инициализира в конструктора. Преди това си прави метод за добавяне на котки към List<Cat> cats:
public void AddCat(Cat cat, string name)
{
	if(this.cats.Contains(cat))
	{
		throw new ArgumentException("...");
	}
	cat.Name = name;
	cat.Owner= this;
	this.cats.Add(cat);	
}				Но сега за да работи трябва да добави листа в контруктора. Задължително там трябва да кажем: this.cats = new List<Cat>(); 
	Ще го направя като проект по лекцията на Ивайло във VS. 

Когато в полетата отгоре се декларира масив, или някаква лист колекция, тогава в конструктора задължително с това име (декларираното горе) се дава образуване на инстанция с new ... . В статичния контруктор при статични масиви може да има и цикъл с инициализацията на този масив. 

Интересен начин на използване на подполетата е дадено във демото DefiningClass-2, 2.Structures: /така прави цвета/в 
public override string ToString() -> "surface(#{4:X2}{5:X2}{6:X2}), border(#{7:X2}{8:X2}{9:X2})", this.SufaceColor.RedValue, this.SurfaceColor.GreeVlue, this.SurfaceColor.BlueValue и същото за 7, 8 и 9 но BorderColor.
	Важно! Навсякъде където има пропертита, а и в методите ползва this.

	Важно!!! Всички неща, които искаме да са използват, има ги в полетата горе, за да работят трябва да се инстанцират в конструктора. Иначе няма да работят!!! Горе има: private List<Cat> cats; В конструктора трябва да добави: 
this.cats = new List<Cat>(); т.е. да направи инстанция на листа (или масива). Тогава вече той ще работи. Може би затова не мога да използвам battery и display при GSM-a. от първото домашно. 
В конструктора пишем this.Name = name; С главна буква, за да мине през пропертито и да изпълни валидацията. Там където нямаме полета - може автоматично проперти за това свойство. Иначе с поле и с валидация. Пишеш само автоматични пропертита, ако ти трябва валидация - с полета и неавтоматични пропертита. 
	До тук беше преговор от първата лекция - това за котките. 

Статични неща - могат да се сетват на: Fields, Properties, Methods, Events, Constructors. Статичното е общо за целия клас и се достъпва през името на класа (с гл. буква); Нестатичното е свързано с инстанцията и се достъпва през нея (след като се направи спооред конструктора с new ... . 
	Ако един клас е статичен, нищо инстанционно не може да съществува в него и не можем да създаваме такова. В общия случай искаме нещата да не са статични. 

Структури - Стойностни типове данни и се държат като примитивни типове данни. Структурата се копира, докато класа се подава по референция. Структури се използват когато имаме да пазим няколко данни. Координати на точка, и др. Когато обаче имаме някаква логика - да е клас. Иначе няма голяма разлика между тях class and struct, но в памета се държат по различен начин. Всички примитивни типове данни са структури. Само стринга е клас, но се държи като примитивни данни.

Generics class - GenericList<T>, T = int, string, Cat, ... може и два параметъра: Generic<T, K>. При създаване на инстанцията, трябва да укажем типа/типовете данни. Има обаче известни ограничения. Това Т се държи като обект. Т.е. компилаторът не знае какъв е типа данни, т.е. не можем да извършваме някои операции. (Събиране, изваждане умнажение... сравняване... ) Имаме някакви възможности да ги сравняваме, но по-нататък. Можем да кажем измежду какви типове данни да бъде Generic - a.

Освен Generic класове можем да имаме Generic методи.  Можем да направим метода Generic за да работи с повече от 1 тип данни, за да не правим  едно и също. Когато имаме where T: struct  или where T: class веднъж работи само със структури, а в другия случай - с класове, но не и със структури като int, bool, long... Когато след where има new() означава да има празен конструктор. Могат след where да се изреждат, но редът е: class, IComparable<T> 

Неймспейси . В тях се съдържат класове (дефиници на типове). След като се смени неймспейса на даден клас, той вече не разпознава другите класове, които не са в този неймспейс. Ако са в различни неймспейси, можем да укажем отгоре с using кой неймспейс да разпознава допълнително (освен собствения неймспейс) този клас. 
	Всеки един неймспейс не е задължително да се дефинира в един и същи файл. Всеки от класовете на неймспейса вижда останалите, които са в същия неймспейс. По този начин можем да имаме с еднакви имена класове, но в различни неймспейси. Горе преди мейн метода указваме using FirstCat = CatSystem.Cat; и също така using SecondCat = AnimalSystem.Cat;

След using .... (горе) точките в името разграничават поднеймспейси. По такъв начин могат да се разграничават и групират нещата. 

Ако един клас стане много дълъг - разделяме на множество класове; Ако един метод стане много дълъг - разделяме на много методи. 
Отговорностите се разделят на по-малки парчета, всяко от което върши конкретна работа. Ако имаме твърде много класове, разделяме ги по неймспейсове. Ако имаме твърде много неймспейси - разделяме ги на отделни проекти. 
	Името на класа трябва да е като името на файла.cs Ако имаме два файла с еднакви имена - разделяме с папки. Това не променя неймспейсите им. Компилаторът се интересува само от неймспейса, а не от това в коя папка е файла. Но е добре структурата като папки трябва да отговаря на неймспейса. 
	Трябва да си изтеглим програмата StyleCop - За правилен/качествен програмен код (по Майкрософт). Къде да се пишат using... дали отгоре, или в неймспейса. Това е според екитъп, с когото работим, както се разберем. И двете работят. Някъде пък е прието полетата да започват с _ . Идва от някои езици. 
	Документацията в кода - /// - три наклонени черти. Описват какво правим в кода. Това може да се използва от другите програмисти, ако ние сме си написали документацията. Там като се напише GenericList<> излиза подсказка, какво е това. Според StyleCop всяко едно нещо трябва да си има документация. Т.е. такова описание. Обикновено се описват нещата, които са трудни за разбиране. Някакъв тежък за схващане алгоритъм, или нещо подобно. В StyleCop - а отменяме "да ни се кара" за документация в настройките. А останалите да остаат. По този начин ще се научим как трябва да се пише качестевн код. 

Индексатори. Можем да правим собствен индексатор, който да сетва или да връща данни в собсвтената колекция. Синтаксисът е както пишем методи и пропертита, т.е. аналогично е: public int this [int index] {...}

Важно!!! Когато имаме колекции (масиви, листове) в полетата, в конструктора трябва да се инициализират/инстанцират с new ...;





Бележки по четвърта лекция други - при преглеждане на видеото

Прави се тестващия клас с Main метода като в него ще пробвам нещата. Прави си папка Models в която поставя класовете - отначало Person - с 2 автоматични порпертита - Email, Name; После си прави клас (пак в папката) Student - наследява Person; И в него нищо няма. Отива в тестващия клас - прави инстанция на студента. Макар че в Student няма нищо, тъй като той наследява Person, може да му направи инстанция, която ще има Еmail, Name; За да го познава обаче, Не добавя горе в кода using ScoolSystem.Models; - в тестващия клас, а променя неймспейсите на всички класове като на тестващия. 

Общите неща изнасяме в един базов клас, вече след това, когато се разминават пропертитата, правим нов клас, наследяващ базовия. Поема всичко като пропертита и методи от базовия, но си има и свои специфични пропертита, които само той си ги има. Така че в Student класа добавя пропертито StudentID. По същия начин постъпва с учителя, После създава UniversityProfessot, кото е под Teacher, т.е. наследява Teacher; и т.н. си направих цялата схема. 

Прави един интерфейс - през клас. С име IPerson. Повечето интерфейси са публични. В тях пише методи и пропертита, но не им дава Access Modeifier - без public, private ... Смята се, че всичко е public, също void метода. На пропертитата маха сетърите, тъй като там те трябва всичко да е public. В интерфейса да няма думата public.

Ако интерфейсът не ни задължава сетъра да го има, правим в наследника - Person сетъра private. Като имплементира Walk гърми, ако няма пропертитата с get, set; Прави конструктор с име и email. Но тогава гърми, защото няма празен (без параметри) конструктор. То гърми, защото при наследяването единствено не се предават конструкторите. Ако нямаше наследяване, нямаше да гърми, тъй като ще си направи по подразбиране празен конструктор. Но сега вижда, че Парент класа, т.е. Person няма конструктор. И дава грешки в неговите наследници - казва, че нямат празен конструктор. 
	Като тръгна да правя конструктори в Student, Teacher, Employse прави конструктора с 2-3 параметъра, но добавя след това : base(name, email) т.е. да използва конструктора на родителския клас. Тук прави конструктор с параметри, но след наследяването тялото на конструктора е празно. Мнаго пъти в пропертитата сетъра е private. По този начин пропертито е почти readOnly и се спазва принципа на капсулация-encapsulation. 
	Ако някои от децата на Person наследи директно интерфейса, трябва да му добавим горе using ... .Тогава пак иска да се имплеметират онези неща - от интерфейса - Name, Email, Walk. Автоматично ги добавя след Ctrl-. 
	Важно! Йерархията се построява, като освен че наследяват Person, се дава и че наследяват IPerson. Тогава пропертитата, които се искаха да ги има в някои от класовете, за да се билдне, могат да се изтрият, тъй като се имплементират от първия наследник на интерфейса - Person. Става дума за пропертитата, които стават подчертани със зелена вълнообразна черта след горното наследяване. 
	Интерфейсът е структурата как трябва да изглежда нещо, докато имплементацията е в наследниците. Наследяват се атрибути (пропертита и полета) и методи, но не се наследяват конструктори. Когато при наследяване в конструктор, се преизползва този на родителя, се пише : base(name, email), докато ако се преизползва този от текущия клас се пише   this(name, subject).  Детето клас наследява base класа/родителя/; класа имплементира интерфейса; наследникът интерфейс разширява (extends) base interface (екстендва) базовия интерфейс. 
	Важно!!! когато искаме да можем да сравняваме двама студенти, в името на класа Student  добадяме също така Student : IComparable<Student> . Веднага излиза да имплементираме метода public int CompareTo(Student other)
	Кога правим наследяване и кога правим проперти? Имаме примерно клас животно и клас сърце. Задаваме си въпроса "is a" (т.е. дали животното е сърце) - отг. Не. Тогава не го наследява, а сърцето е само като проперти. Другият въпрос който задаваме е "has a" (дали животното има сърце). Да. Тогава е проперти. Когатот правим проперти с propg Tab Tab автоматично проперти, при което сетъра е private. Добре е да е така. 
	При интерфейса - всичко което е в него, трябва да бъде имплементирано. Обаче някои членове на интерфейса могат да бъдат inaccessible (hidden). През this могат да се достъпват методите и пропертиатата на текущия клас, докато през base се достъпват тези на родителския клас. Един клас може да наследява само един клас, но няколко интерфейса. 
	Важно! По дървото с наследявания от даден обект - какви интерфейси наследява, може да видим какви методи трябва да имплементира, ако наследи някой от тези интерфейси. F12 клавишът дава достъп до това дърво. Пишем в Main метода един лист List<int> list = new List<int>(); И върху List - a F12  - дава дървото с наследявания от този лист. 
Т.е. Ако искаме да работим с нещо, което искаме да има Add, Clear, Contains, CopyTo, IsReadOnly, то то трябва да наследява ICollection<T>. и оттам нататък да си имплементираме тези методи. 
	С :base(x) се извиква базовия конструктор и му се подават някакви параметри. Chaild класа разширява функционалността на Parent класа, като взема цялата негова функционалност. Ако класът, който наследяваме има повече от 1 конструктор, то можем да подадем след base() някой от тях и мачването е в зависимост от подадените параметри. В базовия клас единия конструктор извиква другия с : this().
   Не само при конструкторите, но и при използване на методите на Парент класа, може вместо this. да използваме base. По този начин може да извикваме метод от Парент класа в текущия Child клас или в някой негов метод. 































Записки по време на лекцията на Ивайло от 13.03.2015 г.

Преговор първите 2-25 мин. 

Създаване на класове - котки, собственици, енумерация, 

Статичните неща излизат с името на класа. 
Докато нестатичните - през инстанцията - конкретната котка. 
Всички статитчни неща не може да се извикват от this.  Могат да се извикват през името на класа. 

Автоматично проперти не трябав да правим, когато искаме да валидираме някакви данни. Те се валидират през пропертито. 
Иначе когато не валидираме, - правим автоматично проперти. Правим само автоматични пропертита, а ако ни трябва валидация, тогава пришем и полета и имаме неавтоматични пропертита. 
Всеки един клас трябва да знае възможно най-малко за  другите класове. 

Статичните - когато за първи път се използват, тогава се зареждат в паметта. А инстанционните се съдават когато се създава инстанцията. 

Прави статичен клас Принтер. В него не може да има нестатичин неща. Обикновено повечето класове не искаме да са статични. Статичните си живеят през цялото време на изпълнение на приложението. 

Структурите са стойностни типове данни и се държат като примитивни типове данни. Structure - value type; Class - refernce type;
структурите винаги имат конструктор без параметри. Да се използват когато трябва да пазим някакви данни. Всяко нещо, което има някаква логика, да е клас, а не структура. Ако променяме някаква структура, тя се копира, като примитивни данни. 


Продължение на лекцията:

Generics  List<int> Шаблонни класове, които приемат всякакъв вид данни. List<T>  когато се използва ,се казва какъв клас се използва. 
Позволяват да се създаде шаблон и да има цялата логика на съответния клас generic.  Клас , който очаква някакъв тип данни при инстанциране. И <T> се замества със съответните типове данни. Има и някои ограничеиня. Този елемент от тип Т се държи като обект. Не могат да се сравняват, и т.н. Може да има и повече от 1 тип данни в <>.  Може да се ограничи какво да е Т: <T> where T: Class, int, Cat
Generics могат да бъдат ограничение по този начин (със синтаксиса  :...) и да работи с тях. 

Освен това може да имаме дженерик методи. 

При неймспейсите, с точки прави под немспейси. За допълнително специфициране на нещата. Когато класовете станат много, разделяме с неймспейси. Ако един клас стане дълъг, разделяме на под класове. Всеки клас да е в отделен файл. И класа се казва с името на файла. Структурата на папките трябва да отговаря на структурата на неймспейсите. 

Style Cop - да го изтеглим и поставим в VS. Това са правилата на Майкрософт за качествен програмен код. след /// се добавя документация за кода. 

Как да си направим собствен индексатор. Индексаторите се пишат като проперти. Проверка за валидност. има 
Прави нещо като дикшънъри, и демонстрира индексатор върху него.  Tuple...  по-добре е да си правим собсвен клас и да не го ползваме. Прави дженерик Tuple.

Atribute - [ ] те не променят нищо по кода. Но дават допълнителна информация за този код. Поставят се горе в началото на класа. Тази информация се пази в крайния компилиран код. 
