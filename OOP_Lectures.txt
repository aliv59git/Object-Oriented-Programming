Бележки по първа лекция: 

Когато въвеждаме константа public const double PI=стойност, трябва да въведем числена стойност. 
Когато въвеждаме рийд онли константа не е нужно да въвеждаме стойност, а само я декларираме с име: public readonly double Size;
В конструктора въвеждаме нейната стойност. Няма проперти. След като веднъж се въведе, стойността не може да се променя. Като const
В Main() се извикват през името на класа с главна буква! Както и всичко статично! При създаване на нова константа, тя се създава като рийд-онли константа през името на класа само! т.е. константа от тип името на класа!
	Важно! Стойността на рийд-онли константата след създадена инстанция (т.е. нова константа през името на класа) се достъпва през инстанцията с точкова нотация и името на тази константа в класа:  c.Size; dou.Size; Така се извиква и отпечатва! 

Внимание! В Сетера се проверява value. Т.е. всички проверки за валидация трябва да бъдат по отношение на "value"!!! Накрая се сетва стойността на съответното проперти с израза this.name = value; (or age, или нещо друго, за каквото е пропертито). 

В конструктора има само public.. и името на класа и () със или без параметри. В пропертито има public.. и int/string/.. С гл.буква
В кода когато пишем this. след това пропертито е с Главна Буква!!! Защото е името на съответното поле, а не неговата стойност. За да могат да се запишат с главна буква в конструктора, т.е. да се минава през пропертито (и съответно да може да се извърши съответната валидация на входните данни) трябва преди това да са направени пропертитата (при тях имената са с гл. букви). Следователно: правим си полетата private (ако има такива); Правим си пропертитата (get; set;), евентуални валидации; И тогава преди тях си правим конструкторите; След тях ако има си правим методите. Валидациите могат да бъдат изнесени накрая в отд. методи. 
След this. с главна буква е в конструкторите; иначе може и с малка буква. 

При енумерациите. Прави се инстанция без new и се присвоява през името на енумерацията съответната конкретна стойност. 
DayOfWeek day = DayOfWeek.Wednesday;

Валидация на данните в пропертитата. След това в Main() също при правенето на инстанции на класа - през try - catch + Exception ex







Записки по време на лекцията на Ивайло от 13.03.2015 г.

Преговор първите 2-25 мин. 

Създаване на класове - котки, собственици, енумерация, 

Статичните неща излизат с името на класа. 
Докато нестатичните - през инстанцията - конкретната котка. 
Всички статитчни неща не може да се извикват от this.  Могат да се извикват през името на класа. 

Автоматично проперти не трябав да правим, когато искаме да валидираме някакви данни. Те се валидират през пропертито. 
Иначе когато не валидираме, - правим автоматично проперти. Правим само автоматични пропертита, а ако ни трябва валидация, тогава пришем и полета и имаме неавтоматични пропертита. 
Всеки един клас трябва да знае възможно най-малко за  другите класове. 

Статичните - когато за първи път се използват, тогава се зареждат в паметта. А инстанционните се съдават когато се създава инстанцията. 

Прави статичен клас Принтер. В него не може да има нестатичин неща. Обикновено повечето класове не искаме да са статични. Статичните си живеят през цялото време на изпълнение на приложението. 

Структурите са стойностни типове данни и се държат като примитивни типове данни. Structure - value type; Class - refernce type;
структурите винаги имат конструктор без параметри. Да се използват когато трябва да пазим някакви данни. Всяко нещо, което има някаква логика, да е клас, а не структура. Ако променяме някаква структура, тя се копира, като примитивни данни. 


Продължение на лекцията:

Generics  List<int> Шаблонни класове, които приемат всякакъв вид данни. List<T>  когато се използва ,се казва какъв клас се използва. 
Позволяват да се създаде шаблон и да има цялата логика на съответния клас generic.  Клас , който очаква някакъв тип данни при инстанциране. И <T> се замества със съответните типове данни. Има и някои ограничеиня. Този елемент от тип Т се държи като обект. Не могат да се сравняват, и т.н. Може да има и повече от 1 тип данни в <>.  Може да се ограничи какво да е Т: <T> where T: Class, int, Cat
Generics могат да бъдат ограничение по този начин (със синтаксиса  :...) и да работи с тях. 

Освен това може да имаме дженерик методи. 

При неймспейсите, с точки прави под немспейси. За допълнително специфициране на нещата. Когато класовете станат много, разделяме с неймспейси. Ако един клас стане дълъг, разделяме на под класове. Всеки клас да е в отделен файл. И класа се казва с името на файла. Структурата на папките трябва да отговаря на структурата на неймспейсите. 

Style Cop - да го изтеглим и поставим в VS. Това са правилата на Майкрософт за качествен програмен код. след /// се добавя документация за кода. 

Как да си направим собствен индексатор. Индексаторите се пишат като проперти. Проверка за валидност. има 
Прави нещо като дикшънъри, и демонстрира индексатор върху него.  Tuple...  по-добре е да си правим собсвен клас и да не го ползваме. Прави дженерик Tuple.

Atribute - [ ] те не променят нищо по кода. Но дават допълнителна информация за този код. Поставят се горе в началото на класа. Тази информация се пази в крайния компилиран код. 
